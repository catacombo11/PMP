/**************************************
 REDDIT ALL-IN ANALYZER for Google Sheets
 Focus: “Will my post get views now?”
 Cols (A=1):
 - E: avg_upv         (trimmed mean pe fereastra [now-3h-AVG_WINDOW, now-3h])
 - F: peak_users      (active_now din /about)  + NOTE: subs, band, momentum
 - G: posts_per_day   (număr/zi în fereastra selectată)
 - H: unique_users    (posteri ∪ comentatori în fereastră; bots/[deleted] excl.)
 - I: upv/com_ratio   (median(score/(comments+1)) în fereastră)
 - D: Tier (score)    [S+, S, A, B, C, D, F]

 Enhancements:
 - Momentum (3–8h): median(score/hour) pentru postări cu vârsta în [3h,8h];
   se combină în “active” prin 60/40 (rt/mom).
 - Size buckets: XS/S/M/L/XL (după subscribers); normalizare în bandă.
 **************************************/

/******** CONFIG ********/
const CLIENT_ID     = 'EqV_ifon5S_P2cs6mN7-Kw';
const CLIENT_SECRET = 'h7aq_eNM7_LT1AM5Ihrb9ds4u5BcOQ';
const UA            = 'gsheets-reddit-analyzer';
const START_ROW     = 2;

// Fereastră de analiză — se termină cu 3h în urmă: [now-EXCLUDE-AVG_WINDOW, now-EXCLUDE]
const EXCLUDE_HOURS_NEW   = 3;         // exclude cele mai noi 3 ore
const AVG_WINDOW_HOURS    = 24*5;      // 5 zile (modifică la nevoie)
const MAX_PAGES           = 20;        // paginare /new (100/poste/pagină)

// Momentum (relativ la “acum”)
const MOMENTUM_MIN_H      = 3;
const MOMENTUM_MAX_H      = 8;

// Comentarii paginate
const COMMENTS_MAX_PAGES  = 8;         // ~800 comentarii max; crește cu atenție

// Batch + pacing
const BATCH_SIZE          = 240;       // rânduri per execuție
const SLEEP_MS            = 140;       // pauză scurtă între subreddits (evită 429)

// Buget execuție Apps Script (~6m)
const MAX_EXEC_MS         = 5*60*1000 - 15000;

// Sheet columns (A=1)
const COL = {SUB:1, TIER:4, AVG_UPV:5, PEAK:6, PPD:7, UNIQUE:8, RATIO:9};

// Weights (sum = 1.00)
const W = {
  upvotes: 0.40,
  unique:  0.15,
  active:  0.30,   // “right now” + momentum (60/40)
  postsVis:0.10,
  ratio:   0.05
};

// Posts/day “sweet spot”
const IDEAL_POSTS = 50;   // μ (pe zi)
const POSTS_SCALE = 35;   // σ

// Normalizare în bandă: p15–p90 (soft)
const PCTL_LO = 15;
const PCTL_HI = 90;

// Filtre useri
const EXCLUDE_USERS = /^(automoderator|\[deleted\])$/i;
const BOT_SUFFIX    = /bot$/i;

/******** MENU ********/
function onOpen(){
  SpreadsheetApp.getUi().createMenu('Reddit Tools')
    .addItem('Start Analyzer','startAnalyzerAll')
    .addItem('Status','statusAnalyzerAll')
    .addItem('Stop','stopAnalyzerAll')
    .addItem('Recalc tiers only','recalcTiersOnly')
    .addItem('Reset progress','resetAnalyzerState')
    .addToUi();
}

function startAnalyzerAll(){
  const p = PropertiesService.getDocumentProperties();
  p.deleteProperty('HALT');
  ensureTrig_();
  runBatch_();
}

function statusAnalyzerAll(){
  const p = PropertiesService.getDocumentProperties();
  toast_(`Progress ${+(p.getProperty('idx')||0)}/${+(p.getProperty('total')||0)}`,5);
}

function stopAnalyzerAll(){
  PropertiesService.getDocumentProperties().setProperty('HALT','1');
  delTrig_();
  toast_('Stop requested',3);
}

function resetAnalyzerState(){
  const p = PropertiesService.getDocumentProperties();
  ['rows','idx','total','HALT'].forEach(k=>p.deleteProperty(k));
  toast_('State reset',3);
}

/******** BATCH CORE ********/
function runBatch_(){
  const lock = LockService.getDocumentLock();
  if(!lock.tryLock(0)) return;
  try{
    const sh = SpreadsheetApp.getActiveSheet();
    const last = sh.getLastRow();
    if (last < START_ROW) return;

    const startTs  = Date.now();
    const deadline = startTs + MAX_EXEC_MS;

    const p = PropertiesService.getDocumentProperties();
    if (p.getProperty('HALT')==='1'){ delTrig_(); return; }

    if(!p.getProperty('rows')){
      const rows = buildMissingRows_(sh, last); // doar rânduri cu E..I lipsă
      p.setProperty('rows', JSON.stringify(rows));
      p.setProperty('idx','0');
      p.setProperty('total', String(rows.length));
      if(!rows.length){ recalcTiersOnly(); delTrig_(); toast_('Nothing to analyze',3); return; }
    }

    const rows = JSON.parse(p.getProperty('rows')||'[]');
    let idx    = +(p.getProperty('idx')||0);
    const end  = Math.min(idx+BATCH_SIZE, rows.length);

    for(let k=idx; k<end; k++){
      if (p.getProperty('HALT')==='1'){ delTrig_(); return; }

      analyzeOne_(sh, rows[k]);  // scrie E..I și nota pe F
      Utilities.sleep(SLEEP_MS);

      if (Date.now() > deadline){
        p.setProperty('idx', String(k+1));
        toast_(`Yield at ${k+1}/${rows.length}`,3);
        return;
      }
    }

    idx = end;
    p.setProperty('idx', String(idx));
    toast_(`Progress ${idx}/${rows.length}`,5);

    if(idx>=rows.length){
      const retryRows = buildMissingRows_(sh, last);
      if (retryRows.length){
        p.setProperty('rows', JSON.stringify(retryRows));
        p.setProperty('idx','0');
        p.setProperty('total', String(retryRows.length));
        toast_(`Retrying ${retryRows.length} rows`,5);
      }else{
        recalcTiersOnly();
        ['rows','idx','total'].forEach(p.deleteProperty, p);
        delTrig_();
        toast_('All done',3);
      }
    }
  } finally { lock.releaseLock(); }
}

/******** Build list of rows with E–I missing ********/
function buildMissingRows_(sh, last){
  const A = sh.getRange(START_ROW, COL.SUB, last-START_ROW+1, 1).getValues().flat();
  const M = sh.getRange(START_ROW, COL.AVG_UPV, last-START_ROW+1, 5).getValues();
  const rows = [];
  for (let i=0;i<A.length;i++){
    const sub = String(A[i]||'').trim();
    if (!sub) continue;
    const m = M[i];
    const missing = !(m && m.length===5 && m.every(v => v!=='' && v!==null));
    if (missing) rows.push(START_ROW+i);
  }
  return rows;
}

/******** Per-sub: collect E..I în fereastra 5 zile + momentum + band ********/
function analyzeOne_(sh, row){
  const sub = String(sh.getRange(row, COL.SUB).getValue()||'').replace(/^r\//,'').trim();
  if(!sub) return;

  const now       = Math.floor(Date.now()/1000);
  const windowEnd = now - EXCLUDE_HOURS_NEW*3600;              // now-3h
  const windowBeg = windowEnd - AVG_WINDOW_HOURS*3600;         // now-3h-AVG_WINDOW
  const momMin    = now - MOMENTUM_MAX_H*3600;                 // now-8h
  const momMax    = now - MOMENTUM_MIN_H*3600;                 // now-3h

  // Parallel: /about, prima pagină /new, prima pagină /comments
  const base = `https://oauth.reddit.com/r/${encodeURIComponent(sub)}`;
  const [about, firstPosts, firstComments] = oauthJSONFetchAll_([
    `${base}/about`,
    `${base}/new?limit=100`,
    `${base}/comments?limit=100&sort=new`
  ]);

  const active_now  = (about && (about.data?.active_user_count || about.data?.accounts_active)) || 0;
  const subscribers = +((about && about.data?.subscribers) || 0);
  const band        = sizeBand_(subscribers);

  // Paginare postări până coborâm sub windowBeg sau epuizăm paginile
  let posts = ((firstPosts?.data?.children)||[]).map(x=>x.data).filter(Boolean);
  let after = firstPosts?.data?.after || null;
  let pages = 1;

  while(after && pages < MAX_PAGES){
    const url = `${base}/new?limit=100&after=${encodeURIComponent(after)}`;
    const j   = oauthJSON_(url);
    const batch = (j?.data?.children||[]).map(x=>x.data).filter(Boolean);
    if(!batch.length) break;
    posts = posts.concat(batch);
    after = j.data.after;
    pages++;
    const lastUtc = batch[batch.length-1]?.created_utc || 0;
    if(lastUtc < windowBeg) break;
    Utilities.sleep(120);
  }

  // Fereastra de analiză
  const postsWindow = posts.filter(p=>{
    const t = p?.created_utc||0;
    return t >= windowBeg && t <= windowEnd;
  });

  // Momentum: postări cu vârsta 3–8h
  const postsMomentum = posts.filter(p=>{
    const t = p?.created_utc||0;
    return t >= (now - MOMENTUM_MAX_H*3600) && t <= (now - MOMENTUM_MIN_H*3600);
  });

  // posts_per_day (medie/zi pe fereastră)
  const days = AVG_WINDOW_HOURS / 24;
  const postsPerDay = postsWindow.length / days;

  // avg_upv + ratio + autori postări
  const scores  = [];
  const ratios  = [];
  const posters = new Set();
  for(const p of postsWindow){
    const sc = isFinite(p.score) ? p.score : 0;
    const cm = isFinite(p.num_comments) ? p.num_comments : 0;
    scores.push(sc);
    if(p.author && !EXCLUDE_USERS.test(p.author) && !BOT_SUFFIX.test(p.author)) posters.add(p.author);
    ratios.push(sc / (cm + 1));
  }
  const avgUp    = trimmedMean_(scores, 0.10);
  const ratioMed = median_(ratios);

  // Comentarii paginate în aceeași fereastră (nu doar prima pagină)
  let commentsAll = ((firstComments?.data?.children)||[]).map(x=>x.data).filter(Boolean);
  let afterC = firstComments?.data?.after || null;
  let cPages = 1;

  while (afterC && cPages < COMMENTS_MAX_PAGES) {
    const urlC = `${base}/comments?limit=100&sort=new&after=${encodeURIComponent(afterC)}`;
    const jC   = oauthJSON_(urlC);
    const batchC = (jC?.data?.children||[]).map(x=>x.data).filter(Boolean);
    if (!batchC.length) break;
    commentsAll = commentsAll.concat(batchC);
    afterC = jC.data.after;
    cPages++;
    const lastUtcC = batchC[batchC.length-1]?.created_utc || 0;
    if (lastUtcC < windowBeg) break;
    Utilities.sleep(100);
  }

  const comments = commentsAll.filter(c => {
    const t = c?.created_utc||0;
    return t >= windowBeg && t <= windowEnd;
  });

  const commenters = new Set();
  for(const c of comments){
    if(c.author && !EXCLUDE_USERS.test(c.author) && !BOT_SUFFIX.test(c.author)) commenters.add(c.author);
  }
  const uniqueUsers = new Set([...posters, ...commenters]).size;

  // Momentum rate: median(score/hour) pentru 3–8h
  const momRates = [];
  for(const p of postsMomentum){
    const ageH = Math.max(0.001, (now - (p.created_utc||now))/3600);
    if(ageH >= MOMENTUM_MIN_H && ageH <= MOMENTUM_MAX_H){
      const sc = isFinite(p.score) ? p.score : 0;
      momRates.push(sc / ageH);
    }
  }
  const momentum = momRates.length ? median_(momRates) : 0;

  // Scriere în bloc (E..I) + notă pe F
  sh.getRange(row, COL.AVG_UPV, 1, 5).setValues([[
    isFinite(avgUp)?avgUp:0,
    active_now,
    isFinite(postsPerDay)?postsPerDay:0,
    uniqueUsers,
    isFinite(ratioMed)?ratioMed:0
  ]]);

  const metaNote = `subs=${subscribers}|band=${band}|mom=${Number(momentum).toFixed(3)}`;
  sh.getRange(row, COL.PEAK).setNote(metaNote);
}

/******** Tiers: band-aware scaling + momentum blend (60/40) ********/
function recalcTiersOnly(){
  const sh = SpreadsheetApp.getActiveSheet();
  const last = sh.getLastRow();
  if(last<START_ROW) return;

  const rowsN = last - START_ROW + 1;

  const M      = sh.getRange(START_ROW, COL.AVG_UPV, rowsN, 5).getValues(); // E..I
  const Fnotes = sh.getRange(START_ROW, COL.PEAK,    rowsN, 1).getNotes().flat();

  const bands = new Array(rowsN);
  const momentumArr = new Array(rowsN);
  const subsArr = new Array(rowsN);

  for(let i=0;i<rowsN;i++){
    const parsed = parsePeakMeta_(Fnotes[i]);
    bands[i] = parsed.band || 'M';
    momentumArr[i] = parsed.mom || 0;
    subsArr[i] = parsed.subs || 0;
  }

  // Pools per band + pools globale (fallback)
  const bandsAll = ['XS','S','M','L','XL'];
  const pools = {}; for(const b of bandsAll) pools[b] = { up:[], uniq:[], act:[], ratio:[], mom:[] };
  const global = { up:[], uniq:[], act:[], ratio:[], mom:[] };

  for(let i=0;i<rowsN;i++){
    const r  = M[i];
    const up = n(r[0]), act=n(r[1]), ppd=n(r[2]), unq=n(r[3]), ra=n(r[4]); // ppd folosit doar la gaussian
    const b  = bands[i] || 'M';
    if(up>0){ pools[b].up.push(up); global.up.push(up); }
    if(unq>0){ pools[b].uniq.push(unq); global.uniq.push(unq); }
    if(act>0){ pools[b].act.push(act); global.act.push(act); }
    if(ra>0){ pools[b].ratio.push(ra); global.ratio.push(ra); }
    if(momentumArr[i]>0){ pools[b].mom.push(momentumArr[i]); global.mom.push(momentumArr[i]); }
  }

  const GQ = {
    upLo: qtile_(global.up,   PCTL_LO), upHi: qtile_(global.up,   PCTL_HI),
    uqLo: qtile_(global.uniq, PCTL_LO), uqHi: qtile_(global.uniq, PCTL_HI),
    acLo: qtile_(global.act,  PCTL_LO), acHi: qtile_(global.act,  PCTL_HI),
    raLo: qtile_(global.ratio,PCTL_LO), raHi: qtile_(global.ratio,PCTL_HI),
    moLo: qtile_(global.mom,  PCTL_LO), moHi: qtile_(global.mom,  PCTL_HI)
  };

  const Q = {};
  for(const b of bandsAll){
    const pb = pools[b];
    const qb = {
      upLo: qtile_(pb.up,   PCTL_LO), upHi: qtile_(pb.up,   PCTL_HI),
      uqLo: qtile_(pb.uniq, PCTL_LO), uqHi: qtile_(pb.uniq, PCTL_HI),
      acLo: qtile_(pb.act,  PCTL_LO), acHi: qtile_(pb.act,  PCTL_HI),
      raLo: qtile_(pb.ratio,PCTL_LO), raHi: qtile_(pb.ratio,PCTL_HI),
      moLo: qtile_(pb.mom,  PCTL_LO), moHi: qtile_(pb.mom,  PCTL_HI)
    };
    // fallback dacă banda e prea subțire
    Q[b] = {
      upLo: isFinite(qb.upLo)&&isFinite(qb.upHi)&&qb.upHi>qb.upLo ? qb.upLo : GQ.upLo,
      upHi: isFinite(qb.upLo)&&isFinite(qb.upHi)&&qb.upHi>qb.upLo ? qb.upHi : GQ.upHi,
      uqLo: isFinite(qb.uqLo)&&isFinite(qb.uqHi)&&qb.uqHi>qb.uqLo ? qb.uqLo : GQ.uqLo,
      uqHi: isFinite(qb.uqLo)&&isFinite(qb.uqHi)&&qb.uqHi>qb.uqLo ? qb.uqHi : GQ.uqHi,
      acLo: isFinite(qb.acLo)&&isFinite(qb.acHi)&&qb.acHi>qb.acLo ? qb.acLo : GQ.acLo,
      acHi: isFinite(qb.acLo)&&isFinite(qb.acHi)&&qb.acHi>qb.acLo ? qb.acHi : GQ.acHi,
      raLo: isFinite(qb.raLo)&&isFinite(qb.raHi)&&qb.raHi>qb.raLo ? qb.raLo : GQ.raLo,
      raHi: isFinite(qb.raLo)&&isFinite(qb.raHi)&&qb.raHi>qb.raLo ? qb.raHi : GQ.raHi,
      moLo: isFinite(qb.moLo)&&isFinite(qb.moHi)&&qb.moHi>qb.moLo ? qb.moLo : GQ.moLo,
      moHi: isFinite(qb.moLo)&&isFinite(qb.moHi)&&qb.moHi>qb.moLo ? qb.moHi : GQ.moHi
    };
  }

  const out = [];
  for(let i=0;i<rowsN;i++){
    const up=n(M[i][0]), act=n(M[i][1]), ppd=n(M[i][2]), unq=n(M[i][3]), ra=n(M[i][4]);
    const b = bands[i] || 'M';
    const q = Q[b];

    const sUp   = scale01_(up,  q.upLo, q.upHi);            // ↑
    const sUniq = scale01_(unq, q.uqLo, q.uqHi);            // ↑
    const sAct0 = scale01_(act, q.acLo, q.acHi);            // ↑ (real-time)
    const sMom  = scale01_(momentumArr[i], q.moLo, q.moHi); // ↑
    const sAct  = 0.60*sAct0 + 0.40*sMom;                   // 60/40

    const sVis  = gaussian_(ppd, IDEAL_POSTS, POSTS_SCALE); // sweet spot
    const sRat  = 1 - scale01_(ra, q.raLo, q.raHi);         // ↓

    const score = Math.round(100*(W.upvotes*sUp + W.unique*sUniq + W.active*sAct + W.postsVis*sVis + W.ratio*sRat));

    const tier = score>=90 ? 'S+'
               : score>=82 ? 'S'
               : score>=72 ? 'A'
               : score>=62 ? 'B'
               : score>=48 ? 'C'
               : score>=34 ? 'D'
               : 'F';

    out.push([`${tier} (${score})`]);

    const note = `band:${b} subs:${subsArr[i]} | up:${sUp.toFixed(2)} uniq:${sUniq.toFixed(2)} act:${sAct.toFixed(2)} (rt:${sAct0.toFixed(2)} mom:${sMom.toFixed(2)}) vis:${sVis.toFixed(2)} ratio:${sRat.toFixed(2)}`;
    sh.getRange(START_ROW+i, COL.TIER).setNote(note);
  }
  sh.getRange(START_ROW, COL.TIER, rowsN, 1).setValues(out);
}

/******** Size buckets ********/
function sizeBand_(subs){
  if(!isFinite(subs)||subs<=0) return 'M';
  if(subs < 100000)  return 'XS';
  if(subs < 500000)  return 'S';
  if(subs < 1000000) return 'M';
  if(subs < 5000000) return 'L';
  return 'XL';
}

// Parse meta note pe F: "subs=123|band=M|mom=4.321"
function parsePeakMeta_(note){
  const s = String(note||'');
  const out = { subs:0, band:'M', mom:0 };
  const subsM = s.match(/(?:^|\|)subs=(\d+)/i);
  const bandM = s.match(/(?:^|\|)band=([A-Z]+)/i);
  const momM  = s.match(/(?:^|\|)mom=([0-9.]+)/i);
  if(subsM) out.subs = +subsM[1];
  if(bandM) out.band = bandM[1];
  if(momM)  out.mom  = +momM[1];
  return out;
}

/******** OAUTH + FETCH ********/
function oauthJSON_(url){
  for(let a=0;a<4;a++){
    try{
      const r = UrlFetchApp.fetch(url,{
        headers:{'Authorization':'Bearer '+getToken_(),'User-Agent':UA},
        muteHttpExceptions:true
      });
      const code = r.getResponseCode();
      if(code===200) return JSON.parse(r.getContentText());
      if(code===401) invalidateToken_();
      if(code===429) Utilities.sleep(900*(a+1));
    }catch(e){}
    Utilities.sleep(300*(a+1));
  }
  return null;
}

// fetchAll pentru /about, /new, /comments în paralel
function oauthJSONFetchAll_(urls){
  const token = getToken_();
  const reqs = urls.map(u=>({url:u, headers:{'Authorization':'Bearer '+token,'User-Agent':UA}, muteHttpExceptions:true}));
  const res  = UrlFetchApp.fetchAll(reqs);
  return res.map(r=>{
    try{
      if (r.getResponseCode()===200) return JSON.parse(r.getContentText());
    }catch(e){}
    return null;
  });
}

function getToken_(){
  const cache = CacheService.getScriptCache();
  const hit = cache.get('reddit_token');
  if(hit) return hit;
  const resp = UrlFetchApp.fetch('https://www.reddit.com/api/v1/access_token',{
    method:'post',
    payload:{grant_type:'client_credentials'},
    headers:{
      'Authorization':'Basic '+Utilities.base64Encode(CLIENT_ID+':'+CLIENT_SECRET),
      'User-Agent':UA
    },
    muteHttpExceptions:true
  });
  if(resp.getResponseCode()!==200) throw new Error('oauth failed');
  const data = JSON.parse(resp.getContentText());
  const token = data.access_token;
  cache.put('reddit_token', token, Math.max(60,(data.expires_in||3600)-120));
  return token;
}
function invalidateToken_(){ CacheService.getScriptCache().remove('reddit_token'); }

/******** UTILS ********/
function n(v){ const x=Number(v); return isFinite(x)?x:0; }

function median_(arr){
  if(!arr.length) return 0;
  const a=arr.slice().sort((x,y)=>x-y);
  const m=Math.floor(a.length/2);
  return a.length%2 ? a[m] : (a[m-1]+a[m])/2;
}

function trimmedMean_(arr, alpha){
  const a = arr.filter(x=>isFinite(x));
  if(!a.length) return 0;
  a.sort((x,y)=>x-y);
  const k = Math.floor(alpha*a.length);
  const slice = a.slice(k, a.length-k);
  const s = slice.reduce((t,x)=>t+x,0);
  return s / Math.max(1, slice.length);
}

function qtile_(arr, p){
  if(!arr.length) return 0;
  const a = arr.slice().sort((x,y)=>x-y);
  const idx = (p/100)*(a.length-1);
  const lo = Math.floor(idx), hi = Math.ceil(idx), w = idx-lo;
  return lo===hi ? a[lo] : a[lo]*(1-w)+a[hi]*w;
}

function scale01_(x, lo, hi){
  if(!isFinite(x)) return 0;
  if(!(isFinite(lo)&&isFinite(hi)) || hi<=lo) return 0;
  const t = (x-lo)/(hi-lo);
  if(t<0) return 0;
  if(t>1) return 1;
  return t;
}

function gaussian_(x, mu, sigma){
  if(!isFinite(x)||sigma<=0) return 0;
  const z = x-mu;
  return Math.exp(-(z*z)/(2*sigma*sigma));
}

/******** MAINTENANCE (rulezi o dată dacă ai trigger-e rămase) ********/
function killAllTriggersOnce(){
  ScriptApp.getProjectTriggers().forEach(ScriptApp.deleteTrigger);
}

function ensureTrig_(){
  const has = ScriptApp.getProjectTriggers().some(t=>t.getHandlerFunction()==='runBatch_');
  if(!has) ScriptApp.newTrigger('runBatch_').timeBased().everyMinutes(1).create();
}

function delTrig_(){
  ScriptApp.getProjectTriggers().forEach(t=>{
    if(t.getHandlerFunction()==='runBatch_') ScriptApp.deleteTrigger(t);
  });
}

function toast_(m,s){ SpreadsheetApp.getActive().toast(m,'Reddit Tools',s); }
